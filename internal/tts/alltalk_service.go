package tts

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"go.uber.org/zap"
)

// AllTalkService –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å Text-to-Speech —á–µ—Ä–µ–∑ AllTalk TTS
type AllTalkService struct {
	logger    *zap.Logger
	baseURL   string
	httpClient *http.Client
}

// NewAllTalkService —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π AllTalk TTS —Å–µ—Ä–≤–∏—Å
func NewAllTalkService(logger *zap.Logger, baseURL string) *AllTalkService {
	return &AllTalkService{
		logger: logger,
		baseURL: baseURL,
		httpClient: &http.Client{
			Timeout: 120 * time.Second,
		},
	}
}

// SynthesizeText –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–µ–∫—Å—Ç –≤ –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ AllTalk TTS
func (s *AllTalkService) SynthesizeText(ctx context.Context, text string) ([]byte, error) {
	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
	if len(text) > 500 {
		text = text[:500] + "..."
	}

	// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–≤ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—à–∏–±–æ–∫
	words := strings.Fields(text)
	if len(words) > 50 {
		text = strings.Join(words[:50], " ") + "..."
	}

	// –û—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
	cleanText := s.cleanText(text)

	s.logger.Info("üéµ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ AllTalk TTS",
		zap.String("text", cleanText),
		zap.Int("text_length", len(cleanText)))

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ AllTalk TTS
	audioData, err := s.generateAudio(ctx, cleanText)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞—É–¥–∏–æ: %w", err)
	}

	s.logger.Info("üéµ –∞—É–¥–∏–æ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ",
		zap.String("text", cleanText),
		zap.Int("audio_size", len(audioData)))

	return audioData, nil
}

// generateAudio –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ AllTalk TTS API
func (s *AllTalkService) generateAudio(ctx context.Context, text string) ([]byte, error) {
	// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
	data := url.Values{}
	data.Set("text_input", text)
	data.Set("text_filtering", "standard")
	data.Set("character_voice_gen", "female_01.wav")
	data.Set("narrator_enabled", "false")
	data.Set("text_not_inside", "character")
	data.Set("language", "en")
	data.Set("output_file_name", fmt.Sprintf("tts_%d", time.Now().UnixNano()))
	data.Set("output_file_timestamp", "true")
	data.Set("autoplay", "false")
	data.Set("autoplay_volume", "0.8")

	// –°–æ–∑–¥–∞–µ–º HTTP –∑–∞–ø—Ä–æ—Å
	req, err := http.NewRequestWithContext(ctx, "POST", s.baseURL+"/api/tts-generate", strings.NewReader(data.Encode()))
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞: %w", err)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	s.logger.Info("üéµ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ AllTalk TTS",
		zap.String("url", req.URL.String()),
		zap.String("text", text))

	// –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
	resp, err := s.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞: %w", err)
	}
	defer resp.Body.Close()

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("AllTalk TTS –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É %d: %s", resp.StatusCode, string(body))
	}

	// –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
	responseBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞: %w", err)
	}

	// –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
	var response struct {
		Status         string `json:"status"`
		OutputFilePath string `json:"output_file_path"`
		OutputFileURL  string `json:"output_file_url"`
	}

	if err := json.Unmarshal(responseBody, &response); err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–≤–µ—Ç–∞: %w", err)
	}

	if response.Status != "generate-success" {
		return nil, fmt.Errorf("AllTalk TTS –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å: %s", response.Status)
	}

	// –°–∫–∞—á–∏–≤–∞–µ–º –∞—É–¥–∏–æ —Ñ–∞–π–ª
	audioData, err := s.downloadAudioFile(ctx, response.OutputFileURL)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∞—É–¥–∏–æ: %w", err)
	}

	return audioData, nil
}

// downloadAudioFile —Å–∫–∞—á–∏–≤–∞–µ—Ç –∞—É–¥–∏–æ —Ñ–∞–π–ª –ø–æ URL
func (s *AllTalkService) downloadAudioFile(ctx context.Context, audioURL string) ([]byte, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", audioURL, nil)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: %w", err)
	}

	resp, err := s.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∞—É–¥–∏–æ: —Å—Ç–∞—Ç—É—Å %d", resp.StatusCode)
	}

	// –ß–∏—Ç–∞–µ–º –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ
	var buf bytes.Buffer
	if _, err := io.Copy(&buf, resp.Body); err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã—Ö: %w", err)
	}

	return buf.Bytes(), nil
}

// cleanText –æ—á–∏—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –æ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
func (s *AllTalkService) cleanText(text string) string {
	// –£–±–∏—Ä–∞–µ–º HTML —Ç–µ–≥–∏
	text = strings.ReplaceAll(text, "<b>", "")
	text = strings.ReplaceAll(text, "</b>", "")
	text = strings.ReplaceAll(text, "<i>", "")
	text = strings.ReplaceAll(text, "</i>", "")
	text = strings.ReplaceAll(text, "<tg-spoiler>", "")
	text = strings.ReplaceAll(text, "</tg-spoiler>", "")

	// –£–±–∏—Ä–∞–µ–º —ç–º–æ–¥–∑–∏
	text = strings.ReplaceAll(text, "üéµ", "")
	text = strings.ReplaceAll(text, "üá∑üá∫", "")
	text = strings.ReplaceAll(text, "üá∫üá∏", "")

	// –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
	text = strings.TrimSpace(text)
	text = strings.ReplaceAll(text, "  ", " ")

	return text
}
